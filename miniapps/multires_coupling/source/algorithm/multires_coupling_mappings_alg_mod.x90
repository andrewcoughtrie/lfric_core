!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Base algorithm that contains the various mappings used in the
!>       physics-dynamics multires_coupling miniapp
module multires_coupling_mappings_alg_mod

  use constants_mod,                  only : i_def, r_def
  use mesh_collection_mod,            only : mesh_collection
  use mesh_mod,                       only : mesh_type
  use geometric_constants_mod,        only : get_panel_id
  use field_mod,                      only : field_type

  implicit none

  private

  public :: map_w2_vectors_alg, map_scalars_alg

contains

  !> @details An algorithm for mapping W2 vector fields. Note this is
  !> a temporary subroutine which is a placeholder until the W2 mappings
  !> are on trunk
  !> @param[in] source_field  Source W2 field
  !> @param[in,out] target_field  Target W2 field
  subroutine map_w2_vectors_alg( source_field, target_field )

    implicit none

    type(field_type),    intent(in)    :: source_field
    type(field_type),    intent(inout) :: target_field

    type(field_type), pointer :: panel_id_source => null()
    type(field_type), pointer :: panel_id_target => null()
    type(mesh_type),  pointer :: source_mesh => null()
    type(mesh_type),  pointer :: target_mesh => null()
    integer(kind=i_def)       :: source_mesh_id
    integer(kind=i_def)       :: target_mesh_id
    integer(kind=i_def)       :: source_ncells
    integer(kind=i_def)       :: target_ncells


    ! Get source and target mesh id's and meshes
    source_mesh_id = source_field%get_mesh_id()
    target_mesh_id = target_field%get_mesh_id()
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)

    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    ! Get panel id fields
    panel_id_source => get_panel_id(source_mesh_id)
    panel_id_target => get_panel_id(target_mesh_id)

    ! Map W2 vector field from source to target. For now the target fields are
    ! just set to be a constant. This is because the W2 mappings are not on trunk
    ! yet
    if (source_ncells > target_ncells) then
      call invoke( setval_c(target_field, 0.0_r_def) )
    else if (source_ncells < target_ncells) then
      call invoke( setval_c(target_field, 0.0_r_def ) )
    else
      call invoke( setval_X(target_field, source_field) )
    end if

  end subroutine map_w2_vectors_alg

  !> @details An algorithm for mapping scalar fields
  !> @param[in] source_field  Source field
  !> @param[in,out] target_field Target field
  subroutine map_scalars_alg( source_field, target_field )

    use prolong_kernel_mod,  only: prolong_kernel_type
    use restrict_kernel_mod, only: restrict_kernel_type

    implicit none

    type(field_type),    intent(in)    :: source_field
    type(field_type),    intent(inout) :: target_field

    type(mesh_type), pointer  :: source_mesh => null()
    type(mesh_type), pointer  :: target_mesh => null()
    integer(kind=i_def)       :: source_mesh_id
    integer(kind=i_def)       :: target_mesh_id
    integer(kind=i_def)       :: source_ncells
    integer(kind=i_def)       :: target_ncells


    ! Get source and target mesh id's and meshes
    source_mesh_id = source_field%get_mesh_id()
    target_mesh_id = target_field%get_mesh_id()
    source_mesh => mesh_collection%get_mesh(source_mesh_id)
    target_mesh => mesh_collection%get_mesh(target_mesh_id)

    ! Figure out which of the meshes has fewer cells
    source_ncells = source_mesh%get_ncells()
    target_ncells = target_mesh%get_ncells()

    ! Map scalar field from source to target
    if (source_ncells > target_ncells) then
      call invoke( setval_c(target_field, 0.0_r_def), &
                   restrict_kernel_type(target_field, source_field) )
    else if (source_ncells < target_ncells) then
      call invoke( setval_c(target_field, 0.0_r_def ), &
                   prolong_kernel_type(target_field, source_field) )
    else
      call invoke( setval_X(target_field, source_field) )
    end if

  end subroutine map_scalars_alg

end module multires_coupling_mappings_alg_mod
