!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------
!> @brief An algorithm for testing the COSMIC transport scheme
!> @details The algorithm iterates forwards in time and transports the density
!>          field using the COSMIC advection scheme. This implementation
!>          has currently been tested in the biperiodic planar domain and in
!>          the horizontal direction only. The wind profile is defined
!>          analytically.
module cosmic_transport_alg_mod

  use constants_mod,                     only: r_def, str_max_filename, i_def
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use operator_mod,                      only: operator_type
  use restart_control_mod,               only: restart_type
  use finite_element_config_mod,         only: element_order
  use solver_mod,                        only: solver_algorithm
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use fs_continuity_mod,                 only: W0, W1, W2, W3
  use compute_mass_matrix_kernel_w0_mod, only: compute_mass_matrix_kernel_w0_type
  use compute_mass_matrix_kernel_w2_mod, only: compute_mass_matrix_kernel_w2_type
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE
  use solver_config_mod,                 only: method
  use output_config_mod,                 only: diagnostic_frequency

  use psykal_lite_mod,                   only: invoke_copy_field_data,  &
                                               invoke_set_field_scalar

  use initial_u_kernel_mod,              only: initial_u_kernel_type
  use initial_rho_kernel_mod,            only: initial_rho_kernel_type

  use density_update_alg_mod,            only: density_update_alg
  use split_transport_alg_mod,           only: split_transport_alg
  use output_alg_mod,                    only: output_alg

  implicit none

  private
  public :: cosmic_transport_alg

contains

!> @brief An algorithm for testing the COSMIC transport scheme
!> @details The algorithm iterates forwards in time and transports the density
!>          field using the COSMIC advection scheme. This implementation
!>          has currently been tested in the biperiodic planar domain and in
!>          the horizontal direction only. The wind profile is defined
!>          analytically.
!> @param[in] restart checkpoint/restart type with timestepping information
!> @param[inout] u the vector wind field
!> @param[inout] rho the density field
!> @param[inout] chi the fem coordinate field array
!> @param[in] mesh  The mesh all fields are on
  subroutine cosmic_transport_alg(mesh_id, chi, u, rho, restart)

    implicit none

    integer(i_def),      intent(in)    :: mesh_id
    type(field_type),    intent(inout) :: u, rho, chi(3)
    type(restart_type),  intent(in)    :: restart

    ! output variables
    integer :: dir
    type( quadrature_type )          :: qr
    character(len=str_max_filename)  :: fname

    type( field_type ) :: u_n, u_np1, rho_n, rho_np1, r_u, mass_flux, xi, theta

    type(function_space_type) :: fs
    type(function_space_type), pointer :: w0_fs   => null()
    type(function_space_type), pointer :: w2_fs   => null()
    type(function_space_type), pointer :: w3_fs   => null()

    type(operator_type) :: mm_w2, mm_w0

    integer :: timestep, ts_init

    w0_fs   => function_space_collection%get_fs( mesh_id, element_order, W0 )
    w2_fs   => function_space_collection%get_fs( mesh_id, element_order, W2 )
    w3_fs   => function_space_collection%get_fs( mesh_id, element_order, W3 )

    rho_n   = field_type( vector_space = w3_fs )
    rho_np1 = field_type( vector_space = w3_fs )

    r_u       = field_type( vector_space = w2_fs )
    u_n       = field_type( vector_space = w2_fs )
    u_np1     = field_type( vector_space = w2_fs )
    mass_flux = field_type( vector_space = w2_fs )

    ! Create operators needed for timestepping
    mm_w0 = operator_type(w0_fs, w0_fs)
    mm_w2 = operator_type(w2_fs, w2_fs)

    qr = quadrature_type(element_order+3, GAUSSIAN)

    ! Compute mass matrices
    call invoke( compute_mass_matrix_kernel_w0_type(mm_w0, chi, qr),           &
                 compute_mass_matrix_kernel_w2_type(mm_w2, chi, qr) )

    call log_event( "Dynamo: Computing transport test", LOG_LEVEL_INFO )

    ! Initialise rho and u.
    call invoke_set_field_scalar(0.0_r_def, u)
    call invoke_set_field_scalar(0.0_r_def, r_u)
    call invoke( initial_u_kernel_type( r_u, chi, qr ) )
    call solver_algorithm(u, r_u, mesh_id, chi, method, mm=mm_w2)
    call invoke_copy_field_data(u,u_n)
    call invoke_copy_field_data(u,u_np1)
    call invoke( initial_rho_kernel_type ( rho, chi, qr ) )

    call log_event( "rho and u are initialised", LOG_LEVEL_INFO )

    ! Dummy W0 and W1 field needed for output algorithm
    xi = field_type( vector_space = function_space_collection%get_fs( mesh_id, element_order, w1 ) )
    theta = field_type( vector_space = function_space_collection%get_fs( mesh_id, element_order, w0 ) )
    call invoke_set_field_scalar(0.0_r_def, xi)
    call invoke_set_field_scalar(0.0_r_def, theta)

    ts_init = max( (restart%ts_start() - 1), 0 ) ! 0 or t previous.
    call output_alg(ts_init, theta, xi, u, rho, chi, mesh_id, mm_w0)

    do timestep = restart%ts_start(),restart%ts_end()
      call log_event( "&
      /****************************************************************************\ ", &
                      LOG_LEVEL_TRACE )
      write( log_scratch_space, '(A,I0)' ) 'Start of timestep ', timestep
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      call invoke_copy_field_data(rho,rho_n)

      ! Call algorithm to calculate mass fluxes using COSMIC scheme
      call split_transport_alg( u_n, u_np1, rho_n, chi, mesh_id, mass_flux)

      ! Update density field using rho_n+1 = rho_n + dt * div(mass_flux)
      call density_update_alg(rho_n, mass_flux, rho_np1, mesh_id)

      call rho_np1%log_minmax(LOG_LEVEL_INFO, 'min max rho_np1')

      call invoke_copy_field_data(rho_np1,rho)

      ! Diagnostics
      if ( mod(timestep, diagnostic_frequency) == 0 ) then
        call output_alg(timestep, theta, xi, u, rho, chi, mesh_id, mm_w0)
      end if

    end do

  end subroutine cosmic_transport_alg

end module cosmic_transport_alg_mod
