!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------
!> @brief Algorithm which updates rho using rho_n - dt * div(mass_flux)
!> @details  Inputs are the the mass flux and rho at time level n. Output is rho at
!>           time level n+1. The divergence of the mass flux is calculated and
!>           multiplied by dt and added to the density rho at time n.
module density_update_alg_mod
  
  use constants_mod,                     only: i_def
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use finite_element_config_mod,         only: element_order
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use log_mod,                           only: log_event,            &
                                               log_scratch_space,    &
                                               LOG_LEVEL_INFO,       &
                                               LOG_LEVEL_TRACE

  use timestepping_config_mod,           only: dt
  use psykal_lite_mod,                   only: invoke_axpy
  use rrho_kernel_mod,                   only: rrho_kernel_type

  implicit none

  private
  public :: density_update_alg

contains

!> @brief Algorithm which updates rho using rho_n - dt * div(mass_flux)
!> @details  Inputs are the the mass flux and rho at time level n. Output is rho at
!>           time level n+1. The divergence of the mass flux is calculated and
!>           multiplied by dt and added to the density rho at time n.
!> @param[in] rho_n      density at time n
!> @param[in] mass_flux  mass flux
!> @param[inout] rho     density at time n+1
!> @param[in] mesh_id    mesh id
  subroutine density_update_alg(  rho_n,          &
                                  mass_flux,      &
                                  rho,            &
                                  mesh_id )

    implicit none
 
    type(field_type),    intent(in)     :: rho_n
    type(field_type),    intent(inout)  :: mass_flux
    type(field_type),    intent(inout)  :: rho
    integer(i_def),      intent(in)     :: mesh_id

    type( field_type )                  :: div
    type( quadrature_type )             :: qr
    type(function_space_type)           :: fs
    type(function_space_type), pointer  :: rho_n_fs   => null()

    qr = quadrature_type(element_order+3, GAUSSIAN)

    rho_n_fs => function_space_collection%get_fs( mesh_id, element_order, &
                                                  rho_n%which_function_space() )

    div = field_type( vector_space = rho_n_fs )

    call invoke( rrho_kernel_type( div, mass_flux, qr ) )

    call invoke_axpy(dt, div, rho_n, rho)

  end subroutine density_update_alg

end module density_update_alg_mod
