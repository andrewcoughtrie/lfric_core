!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the transport equation
!>@details An algorithm for timstepping the 3D transport equation using a
!>         multistage explicit Runge-Kutta algorithm.
module rk_transport_mod

  use constants_mod,                     only: r_def, i_def, str_max_filename
  use log_mod,                           only: log_event,         &
                                               log_scratch_space, &
                                               LOG_LEVEL_INFO,    &
                                               LOG_LEVEL_TRACE

  ! Configuration and restart/checkpoint options
  use finite_element_config_mod,         only: element_order
  use restart_control_mod,               only: restart_type
  use solver_config_mod,                 only: method,         &
                                               preconditioner, &
                                               solver_preconditioner_diagonal
  use timestepping_config_mod,           only: dt
  use output_config_mod,                 only: diagnostic_frequency
  use runge_kutta_init_mod,              only: num_rk_stage, ak

  ! PsyKAl-lite kernels
  use psykal_lite_mod,                   only: invoke_axpy,                   &
                                               invoke_copy_field_data,        &
                                               invoke_set_field_scalar

  ! PsyKAl PSYClone kernels
  use compute_mass_matrix_kernel_w0_mod, only: compute_mass_matrix_kernel_w0_type
  use compute_mass_matrix_kernel_w2_mod, only: compute_mass_matrix_kernel_w2_type
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use flux_rhs_kernel_mod,               only: flux_rhs_kernel_type
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type

  ! Derived Types
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use operator_mod,                      only: operator_type

  ! Algorithms
  use solver_mod,                        only: solver_algorithm
  use output_alg_mod,                    only: output_alg

  ! Handles
  use fs_continuity_mod,                 only: W0, W1, W2, W3

  implicit none

  private
  public :: rk_transport

contains

  !> @brief A Runge-Kutta time-discretisation of the transport equation.
  !> @details An algorithm for timstepping the transport equation using the
  !>          Runge-Kutta algortihm. rho and u fields are initialised before
  !>          this algorithm is called.
  !> @param[in]    mesh_id Mesh id of mesh on which the model runs
  !> @param[inout] chi  The finite element form of the coordinates
  !> @param[in]    u The 3D wind field
  !> @param[inout] rho The density
  !> @param[in] restart Checkpoint/restart type with timestepping information
  subroutine rk_transport( mesh_id, chi, u, rho, restart)

    implicit none

    ! Mesh id
    integer(i_def),  intent(in) :: mesh_id
    ! Coordinate fields
    type( field_type ), intent( inout ) :: chi(3)
    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho
    ! Restart for timestep control and diagnostic output control
    type( restart_type ), intent( in )  :: restart

    ! Temporary fields
    type( field_type ) :: rho_n, r_u, r_rho, rho_inc, mass_flux, theta, xi

    type( field_type ), allocatable ::       rr_prediction(:)

    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()
    type(function_space_type), pointer :: w0_fs    => null()
    type(function_space_type), pointer :: w2_fs    => null()

    type(quadrature_type)     :: qr
    type(operator_type)       :: mm_w2, mm_w0

    ! Timestepping variables
    integer :: timestep, ts_init
    integer :: stage, st

    allocate ( rr_prediction(num_rk_stage) )

    !=== Section 1: Create field objects =====================================!
    ! Local fields
    u_fs     => function_space_collection%get_fs(mesh_id, element_order, &
                                                 u%which_function_space())
    rho_fs   => function_space_collection%get_fs(mesh_id, element_order, &
                                                 rho%which_function_space())
    w0_fs    => function_space_collection%get_fs(mesh_id, element_order, W0)
    w2_fs    => function_space_collection%get_fs(mesh_id, element_order, W2)

    qr = quadrature_type(element_order+3, GAUSSIAN)

    rho_n        = field_type( vector_space = rho_fs )
    r_rho        = field_type( vector_space = rho_fs )
    rho_inc      = field_type( vector_space = rho_fs )
    r_u          = field_type( vector_space = u_fs )
    mass_flux    = field_type( vector_space = u_fs )

    do stage = 1,num_rk_stage
      rr_prediction(stage) = field_type( vector_space = rho_fs )
    end do

    ! Create operators needed for timestepping
    mm_w0 = operator_type(w0_fs, w0_fs)
    mm_w2 = operator_type(w2_fs, w2_fs)

    ! Compute mass matrices
    call invoke( compute_mass_matrix_kernel_w0_type(mm_w0, chi, qr),           &
                 compute_mass_matrix_kernel_w2_type(mm_w2, chi, qr) )

    ! Dummy W0 and W1 field needed for output algorithm
    xi = field_type( vector_space =                                           &
                    function_space_collection%get_fs(mesh_id, element_order, W1) )
    call invoke_set_field_scalar(0.0_r_def, xi)
    theta = field_type( vector_space =                                           &
                    function_space_collection%get_fs(mesh_id, element_order, W0) )
    call invoke_set_field_scalar(0.0_r_def, theta)

    call invoke_set_field_scalar(0.0_r_def, mass_flux)

    ! Output initial conditions
    call log_event( "Dynamo: Outputing initial fields", LOG_LEVEL_INFO )
    ts_init = max( (restart%ts_start() - 1), 0 ) ! 0 or t previous.
    call output_alg(ts_init, theta, xi, u, rho, chi, mesh_id, mm_w0)

    !=== Section 2: Timestepping ==============================================!

    do timestep = restart%ts_start(),restart%ts_end()
      call log_event( "&
      /****************************************************************************\ ", &
                      LOG_LEVEL_TRACE )
      write( log_scratch_space, '(A,I0)' ) 'Start of timestep ', timestep
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      call invoke_set_field_scalar(0.0_r_def, rho_n)
      call invoke_copy_field_data(rho,rho_n)

      ! Runge-Kutta algorithm
      do stage = 1,num_rk_stage
        ! Compute advection terms
        ! mass flux ( F = rho * u )
        call invoke_set_field_scalar(0.0_r_def, r_u)
        call invoke(flux_rhs_kernel_type( r_u, u, rho, chi, qr ) )
        call invoke(enforce_bc_kernel_type( r_u ) )

        call invoke_set_field_scalar(0.0_r_def, mass_flux)
        call solver_algorithm( mass_flux, r_u, mesh_id, chi, method, mm=mm_w2 )

        ! Compute rrho = div(F)
        call invoke( rrho_kernel_type  ( rr_prediction(stage), mass_flux, qr ) )

        call invoke_set_field_scalar(0.0_r_def, r_rho)

        do st = 1, stage
          call invoke_axpy(ak(stage,st), rr_prediction(st),r_rho, r_rho)
        end do

        ! Invert mass matrices
        call solver_algorithm( rho_inc, r_rho, mesh_id, chi, method, qr=qr )

        ! Add increments
        call invoke_axpy(dt, rho_inc, rho_n, rho)
      end do

      ! Diagnostics
      if ( mod(timestep, diagnostic_frequency) == 0 ) then
        call output_alg(timestep, theta, xi, u, rho, chi, mesh_id, mm_w0)
      end if

      write( log_scratch_space, '(A,I0)' ) 'End of timestep ', timestep
      call log_event( log_scratch_space, LOG_LEVEL_TRACE )
      call log_event( &
      '\****************************************************************************/ ', &
                      LOG_LEVEL_TRACE )
    end do
    call log_event( "Dynamo: Finished timestep", LOG_LEVEL_INFO )
    !==========================================================================

  end subroutine rk_transport

end module rk_transport_mod
