!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Routines for managing FFSL transport schemes.

module ffsl_control_alg_mod

  ! Constants and types
  use constants_mod,                    only: i_def, r_tran, l_def
  use extrusion_mod,                    only: SHIFTED
  use r_tran_field_mod,                 only: r_tran_field_type
  use function_space_collection_mod,    only: function_space_collection
  use function_space_mod,               only: function_space_type
  use fs_continuity_mod,                only: W3, Wtheta
  use geometric_constants_mod,          only: get_panel_id
  use log_mod,                          only: log_event,       &
                                              LOG_LEVEL_INFO,  &
                                              LOG_LEVEL_ERROR, &
                                              LOG_LEVEL_WARNING
  use mesh_mod,                         only: mesh_type
  use mesh_collection_mod,              only: mesh_collection
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_enumerated_types_mod,   only: direction_v,                 &
                                              direction_h,                 &
                                              direction_3d,                &
                                              equation_form_advective,     &
                                              equation_form_conservative,  &
                                              equation_form_consistent
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  ! Algorithms
  use end_of_transport_step_alg_mod,    only: end_of_advective_step_alg, &
                                              end_of_conservative_step_alg
  use ffsl_hori_alg_mod,                only: ffsl_hori_splitting_alg
  use ffsl_vert_alg_mod,                only: ffsl_vert_transport_alg
  use ffsl_3d_alg_mod,                  only: ffsl_3d_splitting_alg

  ! Kernels
  use inject_sh_w3_to_wt_kernel_mod,    only: inject_sh_w3_to_wt_kernel_type
  use inject_wt_to_sh_w3_kernel_mod,    only: inject_wt_to_sh_w3_kernel_type

  ! Configs
  use finite_element_config_mod,        only: element_order
  use subgrid_config_mod,               only: vertical_order

  implicit none

  private

  public :: ffsl_control
  public :: ffsl_consistent_control

contains

  !=============================================================================
  !> @brief Controls 3D/vertical/horizontal FFSL transport.
  !> @details Calls the conservative flux form semi-Lagrangian (FFSL) transport
  !!          scheme step after getting data from transport_metadata and
  !!          transport_runtime.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_control(field_np1, field_n, direction, &
                          step_dt, transport_metadata)

    implicit none

    ! Arguments
    type(r_tran_field_type),         intent(inout) :: field_np1
    type(r_tran_field_type), target, intent(in)    :: field_n
    integer(kind=i_def),             intent(in)    :: direction
    real(kind=r_tran),               intent(in)    :: step_dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata

    ! Internal variables
    logical(kind=l_def)                   :: compute_adv_field
    integer(kind=i_def)                   :: function_space
    type(function_space_type),    pointer :: w3_shifted_fs => null()
    type(mesh_type),              pointer :: mesh => null()
    type(mesh_type),              pointer :: shifted_mesh => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    ! Use pointers inside of this algorithm for field_n and increment
    ! which saves on a field copy
    type(r_tran_field_type),   pointer :: field_n_ptr => null()
    type(r_tran_field_type),   pointer :: increment_ptr => null()
    type(r_tran_field_type),   target  :: field_n_w3_shifted
    type(r_tran_field_type),   target  :: increment_wtheta
    type(r_tran_field_type)            :: mass_flux
    type(r_tran_field_type),   target  :: increment

    call log_event('Conservative FFSL transport', LOG_LEVEL_INFO)

    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    function_space = field_n%which_function_space()

    ! Determine whether individual routines should return a flux or updated field
    compute_adv_field = ( transport_metadata%get_equation_form() == equation_form_advective &
      .or. transport_runtime%get_tracer_step_ctr() /=  transport_runtime%get_num_dry_steps() )

    ! ======================================================================== !
    ! Convert to shifted W3 if required
    ! ======================================================================== !

    if (function_space == Wtheta) then
      ! If the variable is in Wtheta, move into shifted W3
      shifted_mesh => mesh_collection%get_mesh(mesh, SHIFTED)
      w3_shifted_fs => function_space_collection%get_fs(shifted_mesh, 0_i_def, W3)
      call field_n_w3_shifted%initialise( vector_space = w3_shifted_fs )
      call invoke( inject_wt_to_sh_w3_kernel_type(field_n_w3_shifted, field_n) )
      field_n_ptr => field_n_w3_shifted
    else
      ! Stay on current mesh
      field_n_ptr => field_n
    end if

    ! ======================================================================== !
    ! Call routine based on direction: vertical; horizontal; or 3D.
    ! ======================================================================== !

    select case (direction)
    case (direction_v)
      call ffsl_vert_transport_alg(mass_flux, increment, field_n_ptr,           &
                                   step_dt, transport_metadata, vertical_order, &
                                   compute_adv_inc=compute_adv_field)

    case (direction_h)
      call ffsl_hori_splitting_alg(mass_flux, increment, field_n_ptr, &
                                   step_dt, transport_metadata,       &
                                   compute_adv_inc=compute_adv_field)

    case (direction_3d)
      call ffsl_3d_splitting_alg(mass_flux, increment, field_n_ptr, &
                                 step_dt, transport_metadata)

    case default
      call log_event( "FFSL control: Unrecognized direction", LOG_LEVEL_ERROR )

    end select

    ! ======================================================================== !
    ! Convert increment back to Wtheta, if required
    ! ======================================================================== !

    if (function_space == Wtheta) then
      ! If Wtheta variable, move increment back to Wtheta
      call increment_wtheta%initialise( field_n%get_function_space() )
      call invoke( inject_sh_w3_to_wt_kernel_type(increment_wtheta, increment) )
      increment_ptr => increment_wtheta
    else
      ! Stay on current mesh
      increment_ptr => increment
    end if

    ! ======================================================================== !
    ! Use increment to update field_np1, if necessary
    ! ======================================================================== !

    if ( compute_adv_field ) then
      call invoke( X_minus_bY(field_np1, field_n, step_dt, increment_ptr) )
    end if

    ! ======================================================================== !
    ! End of transport step generic routines
    ! ======================================================================== !

    select case ( transport_metadata%get_equation_form() )

    case ( equation_form_conservative, equation_form_consistent )

      ! Include dt in the mass flux
      call invoke( inc_a_times_X(step_dt, mass_flux) )

      ! If this is the final step, field_np1 will be computed here from the fluxes
      ! over the whole transport step
      ! If this is not the final step, field_np1 already includes the *advective*
      ! increment, and may be adjusted to enforce min value or in blending zone
      call end_of_conservative_step_alg(field_np1, field_n, mass_flux, transport_metadata)

    case ( equation_form_advective )
      ! End of step: if necessary enforce min val and overwrite in blending zone
      call end_of_advective_step_alg(field_np1, field_n, transport_metadata)

    case default
      call log_event( "FFSL control: Unrecognized equation", LOG_LEVEL_ERROR )

    end select

    nullify(mesh, shifted_mesh, field_n_ptr, increment_ptr, w3_shifted_fs, &
            transport_runtime)

  end subroutine ffsl_control


  !=============================================================================
  !> @brief Controls consistent and conservative FFSL transport.
  !> @details Calls the transport step for the consistent and conservative flux
  !!          form semi-Lagrangian (FFSL), based on options in the
  !!          transport_metadata.
  !!          NOTE: The proper consistent scheme has not yet been implemented,
  !!          so this is currently a wrapper around standard conservative FFSL.
  !> @param[in,out] field_np1          Field to return at end of transport step
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     direction          Either 3D/vertical/horizontal FFSL transport
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  subroutine ffsl_consistent_control(field_np1, field_n, direction, &
                                     step_dt, transport_metadata)

    use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type

    implicit none

    ! Arguments
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    integer(kind=i_def),           intent(in)    :: direction
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata

    ! Internal variables
    integer(kind=i_def)                   :: split_step
    integer(kind=i_def)                   :: transport_mesh_id
    integer(kind=i_def)                   :: function_space
    real(kind=r_tran)                     :: min_value
    type(r_tran_field_type)               :: field_sh_w3_n, field_sh_w3_np1
    type(r_tran_field_type)               :: rho_X_n, rho_X_np1
    type(r_tran_field_type),      pointer :: rho_d_n => null()
    type(r_tran_field_type),      pointer :: rho_d_np1 => null()
    type(mesh_type),              pointer :: primary_mesh => null()
    type(mesh_type),              pointer :: shifted_mesh => null()
    type(function_space_type),    pointer :: w3_shifted_fs => null()
    type(transport_runtime_type), pointer :: transport_runtime => null()

    call log_event('Consistent FFSL not yet implemented. ' // &
                   'Defaulting to conservative FFSL', LOG_LEVEL_WARNING)

    ! Check function space
    function_space = field_n%which_function_space()

    if (function_space == Wtheta) then
      ! Transport happens in shifted W3
      primary_mesh => field_n%get_mesh()
      shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)
      w3_shifted_fs => function_space_collection%get_fs(shifted_mesh, 0, W3)

      call field_sh_w3_n%initialise( w3_shifted_fs )
      call field_sh_w3_np1%initialise( w3_shifted_fs )
      call rho_X_n%initialise( w3_shifted_fs )
      call rho_X_np1%initialise( w3_shifted_fs )

      transport_mesh_id = shifted_mesh%get_id()
    else
      ! Transport happens in primary W3
      primary_mesh => field_n%get_mesh()

      call rho_X_n%initialise( field_n%get_function_space() )
      call rho_X_np1%initialise( field_n%get_function_space() )

      transport_mesh_id = primary_mesh%get_id()
    end if

    ! Get transport runtime
    transport_runtime => get_transport_runtime(primary_mesh)

    ! Get dry density from transport runtime, for this split step
    split_step = transport_runtime%get_tracer_step_ctr()
    rho_d_n => transport_runtime%get_rho_d_n(transport_mesh_id, split_step)
    rho_d_np1 => transport_runtime%get_rho_d_np1(transport_mesh_id, split_step)

    ! ------------------------------------------------------------------------ !
    ! Turn field into density (possibly on shifted mesh)
    ! ------------------------------------------------------------------------ !

    if (function_space == Wtheta) then
      call invoke( inject_wt_to_sh_w3_kernel_type(field_sh_w3_n, field_n), &
                   X_times_Y(rho_X_n, field_sh_w3_n, rho_d_n) )
    else
      call invoke( X_times_Y(rho_X_n, field_n, rho_d_n) )
    end if

    ! We need the density at the start of the whole transport step, for the
    ! final call to end_of_conservative_step_alg. The mixing ratio is stored by
    ! default, so need to overwrite this. So if this is the first split step
    ! we do this here.
    if (transport_runtime%get_tracer_step_ctr() == 1) then
      call transport_runtime%set_field_n(rho_X_n)
    end if

    ! ------------------------------------------------------------------------ !
    ! Actually transport density using standard conservative FFSL
    ! ------------------------------------------------------------------------ !

    call ffsl_control(rho_X_np1, rho_X_n, direction, &
                      step_dt, transport_metadata)

    ! -------------------------------------------------------------------- !
    ! Return from density (possibly on shifted mesh to field in Wtheta)
    ! -------------------------------------------------------------------- !

    if (function_space == Wtheta) then
      call invoke( X_divideby_Y(field_sh_w3_np1, rho_X_np1, rho_d_np1) )
      ! Turn back to Wtheta. This kernel needs to be in a separate invoke as
      ! the target field is on different mesh to that in previous kernel, so
      ! needs to extract a different "nlayers"
      call invoke( inject_sh_w3_to_wt_kernel_type(field_np1, field_sh_w3_np1) )
      ! This could lead to negative values at top so enforce lower bound
      if ( transport_metadata%get_enforce_min_value() ) then
        min_value = transport_metadata%get_min_value()
        call invoke( enforce_lower_bound_kernel_type(field_np1, min_value) )
      end if
    else
      call invoke( X_divideby_Y(field_np1, rho_X_np1, rho_d_np1) )
    end if

    nullify(transport_runtime, primary_mesh, shifted_mesh, rho_d_n, rho_d_np1, &
            w3_shifted_fs)

  end subroutine ffsl_consistent_control

end module ffsl_control_alg_mod
