!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module for horizontal (2D) FFSL transport.
!> @details Contains algorithms for first and final horizontal FFSL transport
!!          steps. Also contains a control routine for 2D COSMIC splitting.
module ffsl_hori_alg_mod

  ! Constants and types
  use constants_mod,                    only: r_tran, i_def, l_def
  use fem_constants_mod,                only: get_inverse_w3_mass_matrix
  use field_mod,                        only: field_type
  use fs_continuity_mod,                only: W2H, W2Hbroken
  use function_space_mod,               only: function_space_type
  use function_space_collection_mod,    only: function_space_collection
  use geometric_constants_mod,          only: get_panel_id
  use integer_field_mod,                only: integer_field_type
  use mesh_mod,                         only: mesh_type
  use operator_mod,                     only: operator_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use timer_mod,                        only: timer
  use transport_enumerated_types_mod,   only: equation_form_advective,    &
                                              equation_form_conservative, &
                                              equation_form_consistent,   &
                                              direction_h,                &
                                              splitting_strang_hvh,       &
                                              horizontal_monotone_none
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  ! Kernels
  use break_flux_kernel_mod,            only: break_flux_kernel_type
  use ffsl_flux_first_x_kernel_mod,     only: ffsl_flux_first_x_kernel_type
  use ffsl_flux_final_x_kernel_mod,     only: ffsl_flux_final_x_kernel_type
  use ffsl_flux_first_y_kernel_mod,     only: ffsl_flux_first_y_kernel_type
  use ffsl_flux_final_y_kernel_mod,     only: ffsl_flux_final_y_kernel_type
  use ffsl_unify_flux_kernel_mod,       only: ffsl_unify_flux_kernel_type
  use fv_divergence_x_kernel_mod,       only: fv_divergence_x_kernel_type
  use fv_divergence_y_kernel_mod,       only: fv_divergence_y_kernel_type

  ! Configuration options
  use io_config_mod,                    only: subroutine_timers
  use subgrid_config_mod,               only: inner_order, outer_order
  use finite_element_config_mod,        only: element_order
  use transport_config_mod,             only: extended_mesh

  implicit none

  private

  public :: ffsl_hori_splitting_alg
  public :: ffsl_hori_first_alg
  public :: ffsl_hori_final_alg

contains

  !> @brief Algorithm to control 2D horizontal FFSL splitting.
  !> @details Solves the 2D transport equation, in advective or conservative
  !!          form, including controlling the splitting between different
  !!          dimensions. Returns an updated field for advective form and a mass
  !!          flux for conservative form (these are then passed to the generic
  !!          end_of_transport routines).
  !!          One-dimensional flux differences are denoted F and G (while
  !!          the advective differences are f and g).
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !!                                   This is only used when the equation is in
  !!                                   conservative form.
  !> @param[in,out] increment          Increment for the field change over the
  !!                                   time step. Only used when the equation is
  !!                                   in advective form this is not the final
  !!                                   step in a split transport scheme.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     compute_adv_inc    Optional argument as to whether advective
  !!                                   increment should be computed
  subroutine ffsl_hori_splitting_alg( mass_flux, increment, field_n, &
                                      step_dt, transport_metadata,   &
                                      compute_adv_inc )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(inout) :: increment
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    logical(kind=l_def), optional, intent(in)    :: compute_adv_inc

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(mesh_type),              pointer :: mesh => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()

    ! Transport options
    logical(kind=l_def) :: to_compute_adv_inc

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_hori_splitting_alg'

    ! Density substeps in given direction
    type(r_tran_field_type) :: field_x
    type(r_tran_field_type) :: field_y

    ! Field increments and fluxes in given direction
    type(r_tran_field_type) :: first_increment_x
    type(r_tran_field_type) :: first_increment_y
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y
    type(r_tran_field_type) :: flux_x
    type(r_tran_field_type) :: flux_y

    ! Useful constants
    real(kind=r_tran) :: half_dt

    if ( subroutine_timers ) call timer(routine_name)

    ! Get pre-computed objects and set pointers --------------------------------
    mesh => field_n%get_mesh()

    ! Function spaces
    field_fs => field_n%get_function_space()
    w2h_fs => function_space_collection%get_fs( mesh, element_order, W2H )

    if (present(compute_adv_inc)) then
      to_compute_adv_inc = compute_adv_inc
    else
      to_compute_adv_inc = .true.
    end if

    ! Initialise fields used by all splitting options --------------------------
    call field_x%initialise( vector_space = field_fs )
    call field_y%initialise( vector_space = field_fs )
    call mass_flux%initialise( vector_space = w2h_fs )
    call increment%initialise( vector_space = field_fs )

    ! Set constants
    half_dt = 0.5_r_tran * step_dt

    ! COSMIC/Lin-Rood splitting (Leonard et al. 1996, Lin and Rood 1996).
    ! It has the form
    !
    !   rho_x = rho - dt/2 * f(rho)
    !   rho_y = rho - dt/2 * g(rho)
    !
    ! Output: F(rho_y) + G(rho_x)

    ! 1st advective step -------------------------------------------------------
    call ffsl_hori_first_alg( first_increment_x, first_increment_y, field_n,   &
                              step_dt, transport_metadata )
    call invoke( X_minus_bY(field_x, field_n, half_dt, first_increment_x),     &
                 X_minus_bY(field_y, field_n, half_dt, first_increment_y) )

    ! Final step (advective or conservative) -----------------------------------
    call ffsl_hori_final_alg( flux_x, flux_y, increment_x, increment_y,        &
                              field_x, field_y, step_dt, transport_metadata,   &
                              outer_order, compute_adv_inc=to_compute_adv_inc )

    ! Compute advective increment, if required ---------------------------------
    if (to_compute_adv_inc) then
      call invoke( X_plus_Y(increment, increment_x, increment_y) )
    end if

    ! Compute combined mass flux, if required ----------------------------------
    if (transport_metadata%get_equation_form() == equation_form_conservative &
        .or. transport_metadata%get_equation_form() == equation_form_consistent) then
      call invoke( X_minus_Y(mass_flux, flux_x, flux_y) )
    end if

    if ( subroutine_timers ) call timer(routine_name)

    nullify( mesh, w2h_fs, field_fs )

  end subroutine ffsl_hori_splitting_alg

  !> @brief Performs the first advective step of X and Y horizontal FFSL sweeps
  !> @details Calculates the advective increment fields corresponding to X and Y
  !           transport sweeps, from a single input field.
  !> @param[in,out] increment_x        Advective increment from x-sweep.
  !> @param[in,out] increment_y        Advective increment from y-sweep.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     dt                 The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  subroutine ffsl_hori_first_alg( increment_x, increment_y, field_n, &
                                  dt, transport_metadata )

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),         intent(inout) :: increment_x
    type(r_tran_field_type),         intent(inout) :: increment_y
    type(r_tran_field_type), target, intent(in)    :: field_n
    real(kind=r_tran),               intent(in)    :: dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_x => null()
    type(r_tran_field_type),      pointer :: dep_pts_y => null()
    type(r_tran_field_type),      pointer :: detj_at_w2h => null()
    type(field_type),             pointer :: panel_id => null()
    type(r_tran_field_type),      pointer :: adv_one_x => null()
    type(r_tran_field_type),      pointer :: adv_one_y => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_x => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_y => null()
    type(operator_type),          pointer :: m3_inv => null()

    ! Fields and increments
    type(r_tran_field_type), target :: remap_field
    type(r_tran_field_type)         :: flux_x
    type(r_tran_field_type)         :: flux_y
    type(r_tran_field_type)         :: flux_broken
    type(r_tran_field_type)         :: conservative_field_x
    type(r_tran_field_type)         :: conservative_field_y
    type(r_tran_field_type)         :: divide_part
    type(r_tran_field_type)         :: inc_part
    type(r_tran_field_type), target :: dep_pts_x_half
    type(r_tran_field_type), target :: dep_pts_y_half

    ! Pointer to field, to avoid unnecessary setval calculation
    type(r_tran_field_type),   pointer :: field_ptr => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2b_fs => null()

    ! Transport options
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: strang
    logical(kind=l_def) :: monotone_remap

    ! Constants
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: stencil_extent_x
    integer(kind=i_def) :: stencil_extent_y
    integer(kind=i_def) :: cfl_stencil_x
    integer(kind=i_def) :: cfl_stencil_y
    real(kind=r_tran)   :: one_over_dt

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_n%get_mesh_id()
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)

    ! Get pre-computed fields
    dep_pts_x => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y => transport_runtime%get_departure_points_y_w2(mesh_id)
    detj_at_w2h => transport_runtime%get_detj_at_w2_transport(mesh_id, direction_h)
    panel_id => get_panel_id(mesh_id)
    dep_stencil_extent_x => transport_runtime%get_dep_stencil_extent_x(mesh_id)
    dep_stencil_extent_y => transport_runtime%get_dep_stencil_extent_y(mesh_id)

    ! Function spaces
    w2h_fs => dep_pts_x%get_function_space()
    field_fs => field_n%get_function_space()

    ! Get options
    monotone = transport_metadata%get_horizontal_monotone()
    strang = (transport_metadata%get_splitting() == splitting_strang_hvh)

    ! Get unity transport
    if ( strang ) then
      adv_one_x => transport_runtime%get_adv_unity_half_x(mesh_id)
      adv_one_y => transport_runtime%get_adv_unity_half_y(mesh_id)
    else
      adv_one_x => transport_runtime%get_adv_unity_x(mesh_id)
      adv_one_y => transport_runtime%get_adv_unity_y(mesh_id)
    end if

    ! Halve the departure points if using Strang
    if ( strang ) then
      call dep_pts_x_half%initialise( vector_space = w2h_fs )
      call dep_pts_y_half%initialise( vector_space = w2h_fs )
      call invoke( a_times_X(dep_pts_x_half, 0.5_r_tran, dep_pts_x), &
                   a_times_X(dep_pts_y_half, 0.5_r_tran, dep_pts_y) )
      dep_pts_x => dep_pts_x_half
      dep_pts_y => dep_pts_y_half
    end if

    ! Initialise fields
    call increment_x%initialise( vector_space = field_fs )
    call increment_y%initialise( vector_space = field_fs )
    call flux_x%initialise( vector_space = w2h_fs )
    call flux_y%initialise( vector_space = w2h_fs )
    call conservative_field_x%initialise( vector_space = field_fs )
    call conservative_field_y%initialise( vector_space = field_fs )
    call inc_part%initialise( vector_space = field_fs )
    call divide_part%initialise( vector_space = field_fs )

    ! Set constant values
    one_over_dt = 1.0_r_tran / dt
    stencil_extent_x = dep_stencil_extent_x + 1_i_def + inner_order
    stencil_extent_y = dep_stencil_extent_y + 1_i_def + inner_order
    ! PSyclone needs these to be different variables to the stencil_extents
    cfl_stencil_x = stencil_extent_x
    cfl_stencil_y = stencil_extent_y

    ! remap the field on an extended cubed sphere, if required -----------------
    ! If needed remap the field on an extended cubed sphere
    if ( extended_mesh ) then
      monotone_remap = ( monotone /= horizontal_monotone_none )
      call transport_runtime%remap_on_extended_mesh(                  &
                          remap_field, field_n, monotone_remap,       &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value())
      field_ptr => remap_field
    else
      field_ptr => field_n
    end if

    ! Compute the mass fluxes: x-direction -------------------------------------
    call invoke( setval_c(flux_x, 0.0_r_tran),                                 &
                 ffsl_flux_first_x_kernel_type(flux_x, field_ptr,              &
                                               stencil_extent_x, dep_pts_x,    &
                                               detj_at_w2h, inner_order,       &
                                               monotone, cfl_stencil_x, dt),   &
    ! Compute the mass fluxes: y-direction -------------------------------------
                 setval_c(flux_y, 0.0_r_tran),                                 &
                 ffsl_flux_first_y_kernel_type(flux_y, field_ptr,              &
                                               stencil_extent_y, dep_pts_y,    &
                                               detj_at_w2h, inner_order,       &
                                               monotone, cfl_stencil_y, dt) )

    ! fluxes may need unifying to guarantee a unique flux for each face --------
    if ( extended_mesh ) then
      w2b_fs => function_space_collection%get_fs(mesh, element_order, W2Hbroken)
      call flux_broken%initialise( w2b_fs )
      call invoke( break_flux_kernel_type(flux_broken, flux_x, flux_y),        &
                   ffsl_unify_flux_kernel_type(flux_x, flux_y, flux_broken,    &
                                               1, panel_id, 1) )
    end if

    ! Compute updated conservative fields
    call invoke( fv_divergence_x_kernel_type(increment_x, flux_x, m3_inv),     &
                 fv_divergence_y_kernel_type(increment_y, flux_y, m3_inv),     &
                 X_minus_bY(conservative_field_x, field_n, dt, increment_x),   &
                 X_minus_bY(conservative_field_y, field_n, dt, increment_y),   &

    ! Compute advective increments, through division by unity transport --------
    ! Following Putman and Lin, JCP, 2007:
    ! conservative_field = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - conservative_field / adv_one
    ! increment = inc_part / dt
                 X_divideby_Y(divide_part, conservative_field_x, adv_one_x),   &
                 X_minus_Y(inc_part, field_n, divide_part),                    &
                 a_times_X(increment_x, one_over_dt, inc_part),                &
                 X_divideby_Y(divide_part, conservative_field_y, adv_one_y),   &
                 X_minus_Y(inc_part, field_n, divide_part),                    &
                 a_times_X(increment_y, one_over_dt, inc_part) )

    nullify(transport_runtime, mesh, dep_pts_x, dep_pts_y, detj_at_w2h,        &
            panel_id, adv_one_x, adv_one_y, field_ptr, m3_inv, field_fs,       &
            dep_stencil_extent_x, dep_stencil_extent_y, w2h_fs, w2b_fs)

  end subroutine ffsl_hori_first_alg


  !> @brief Performs the final horizontal steps of X and Y horizontal FFSL sweeps
  !> @details Calculates the advective increment fields and/or mass fluxes from
  !!          1D X and Y horizontal FFSL sweeps, in which the inputs to the
  !!          sweeps are different fields.
  !> @param[in,out] flux_x             Mass flux from x-sweep
  !> @param[in,out] flux_y             Mass flux from y-sweep
  !> @param[in,out] increment_x        Advective increment from x-sweep
  !> @param[in,out] increment_y        Advective increment from y-sweep
  !> @param[in]     field_x            Input field from steps in x direction
  !> @param[in]     field_y            Input field from steps in y direction
  !> @param[in]     dt                 The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to use.
  !> @param[in]     compute_adv_inc    Optional argument as to whether advective
  !!                                   increments should be computed
  subroutine ffsl_hori_final_alg( flux_x, flux_y, increment_x, increment_y,    &
                                  field_x, field_y, dt, transport_metadata,    &
                                  order, compute_adv_inc )

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),         intent(inout) :: increment_x
    type(r_tran_field_type),         intent(inout) :: increment_y
    type(r_tran_field_type),         intent(inout) :: flux_x
    type(r_tran_field_type),         intent(inout) :: flux_y
    type(r_tran_field_type), target, intent(in)    :: field_x
    type(r_tran_field_type), target, intent(in)    :: field_y
    real(kind=r_tran),               intent(in)    :: dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata
    integer(kind=i_def),             intent(in)    :: order
    logical(kind=l_def), optional,   intent(in)    :: compute_adv_inc

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_x => null()
    type(r_tran_field_type),      pointer :: dep_pts_y => null()
    type(r_tran_field_type),      pointer :: detj_at_w2h => null()
    type(field_type),             pointer :: panel_id => null()
    type(r_tran_field_type),      pointer :: adv_one_x => null()
    type(r_tran_field_type),      pointer :: adv_one_y => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_x => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_y => null()
    type(operator_type),          pointer :: m3_inv => null()
    type(integer_field_type),     pointer :: cosmic_istart_x => null()
    type(integer_field_type),     pointer :: cosmic_iend_x   => null()
    type(integer_field_type),     pointer :: cosmic_istart_y => null()
    type(integer_field_type),     pointer :: cosmic_iend_y   => null()

    ! Fields and increments
    type(r_tran_field_type), target :: remap_field_x
    type(r_tran_field_type), target :: remap_field_y
    type(r_tran_field_type), target :: dep_pts_x_half
    type(r_tran_field_type), target :: dep_pts_y_half

    type(r_tran_field_type) :: flux_broken
    type(r_tran_field_type) :: conservative_field_x
    type(r_tran_field_type) :: conservative_field_y
    type(r_tran_field_type) :: divide_part
    type(r_tran_field_type) :: inc_part

    ! Flux parts
    type(r_tran_field_type) :: flux_x_high
    type(r_tran_field_type) :: flux_x_low
    type(r_tran_field_type) :: flux_x_int
    type(r_tran_field_type) :: flux_y_high
    type(r_tran_field_type) :: flux_y_low
    type(r_tran_field_type) :: flux_y_int

    ! Pointers to field, to avoid unnecessary setval calculation
    type(r_tran_field_type),   pointer :: field_x_ptr => null()
    type(r_tran_field_type),   pointer :: field_y_ptr => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2b_fs => null()

    ! Transport options
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: strang
    logical(kind=l_def) :: monotone_remap

    ! Constants
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: stencil_extent_x
    integer(kind=i_def) :: stencil_extent_y
    integer(kind=i_def) :: cfl_stencil_x
    integer(kind=i_def) :: cfl_stencil_y

    real(kind=r_tran)   :: one_over_dt
    logical(kind=l_def) :: to_compute_adv_inc

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_x%get_mesh_id()
    mesh => field_x%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)

    ! Get pre-computed fields
    dep_pts_x => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y => transport_runtime%get_departure_points_y_w2(mesh_id)
    detj_at_w2h => transport_runtime%get_detj_at_w2_transport(mesh_id, direction_h)
    panel_id => get_panel_id(mesh_id)
    cosmic_istart_x => transport_runtime%get_cosmic_istart_x(mesh_id)
    cosmic_iend_x => transport_runtime%get_cosmic_iend_x(mesh_id)
    cosmic_istart_y => transport_runtime%get_cosmic_istart_y(mesh_id)
    cosmic_iend_y => transport_runtime%get_cosmic_iend_y(mesh_id)
    dep_stencil_extent_x => transport_runtime%get_dep_stencil_extent_x(mesh_id)
    dep_stencil_extent_y => transport_runtime%get_dep_stencil_extent_y(mesh_id)

    ! Function spaces
    w2h_fs => dep_pts_x%get_function_space()
    field_fs => field_x%get_function_space()

    ! Get options
    monotone = transport_metadata%get_horizontal_monotone()
    strang = (transport_metadata%get_splitting() == splitting_strang_hvh)

    if (present(compute_adv_inc)) then
      to_compute_adv_inc = compute_adv_inc
    else
      to_compute_adv_inc = .true.
    end if

    ! Initialise fields --------------------------------------------------------
    call flux_x%initialise( vector_space = w2h_fs )
    call flux_y%initialise( vector_space = w2h_fs )
    call flux_x_high%initialise( vector_space = w2h_fs )
    call flux_y_high%initialise( vector_space = w2h_fs )
    call flux_x_low%initialise( vector_space = w2h_fs )
    call flux_y_low%initialise( vector_space = w2h_fs )
    call flux_x_int%initialise( vector_space = w2h_fs )
    call flux_y_int%initialise( vector_space = w2h_fs )

    ! Set constant values
    one_over_dt = 1.0_r_tran / dt
    stencil_extent_x = dep_stencil_extent_x + 1_i_def + order
    stencil_extent_y = dep_stencil_extent_y + 1_i_def + order
    ! PSyclone needs these to be different variables to the stencil_extents
    cfl_stencil_x = stencil_extent_x
    cfl_stencil_y = stencil_extent_y

    ! remap the field on an extended cubed sphere, if required -----------------
    ! If needed remap the field on an extended cubed sphere
    if ( extended_mesh ) then
      monotone_remap = ( monotone /= horizontal_monotone_none )
      call transport_runtime%remap_on_extended_mesh(                  &
                          remap_field_x, field_x, monotone_remap,     &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value())
      call transport_runtime%remap_on_extended_mesh(                  &
                          remap_field_y, field_y, monotone_remap,     &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value())
      field_x_ptr => remap_field_x
      field_y_ptr => remap_field_y
    else
      field_x_ptr => field_x
      field_y_ptr => field_y
    end if

    ! Halve the departure points if using Strang
    if ( strang ) then
      call dep_pts_x_half%initialise( vector_space = w2h_fs )
      call dep_pts_y_half%initialise( vector_space = w2h_fs )
      call invoke( a_times_X(dep_pts_x_half, 0.5_r_tran, dep_pts_x), &
                   a_times_X(dep_pts_y_half, 0.5_r_tran, dep_pts_y) )
      dep_pts_x => dep_pts_x_half
      dep_pts_y => dep_pts_y_half
    end if

    ! Compute the mass fluxes: x-direction -------------------------------------
    call invoke( setval_c(flux_x, 0.0_r_tran),                                 &
                 setval_c(flux_x_high, 0.0_r_tran),                            &
                 setval_c(flux_x_low, 0.0_r_tran),                             &
                 setval_c(flux_x_int, 0.0_r_tran),                             &
                 ffsl_flux_final_x_kernel_type(flux_x_high,                    &
                                               flux_x_low, flux_x_int,         &
                                               field_x_ptr, stencil_extent_x,  &
                                               field_y_ptr, stencil_extent_x,  &
                                               cosmic_istart_y, cosmic_iend_y, &
                                               dep_pts_x, detj_at_w2h, order,  &
                                               monotone, cfl_stencil_x, dt),   &
    ! Compute the mass fluxes: y-direction -------------------------------------
                 setval_c(flux_y, 0.0_r_tran),                                 &
                 setval_c(flux_y_high, 0.0_r_tran),                            &
                 setval_c(flux_y_low, 0.0_r_tran),                             &
                 setval_c(flux_y_int, 0.0_r_tran),                             &
                 ffsl_flux_final_y_kernel_type(flux_y_high,                    &
                                               flux_y_low, flux_y_int,         &
                                               field_x_ptr, stencil_extent_y,  &
                                               field_y_ptr, stencil_extent_y,  &
                                               cosmic_istart_x, cosmic_iend_x, &
                                               dep_pts_y, detj_at_w2h, order,  &
                                               monotone, cfl_stencil_y, dt),   &
    ! Combine integer and fractional fluxes ------------------------------------
                 X_plus_Y(flux_x, flux_x_high, flux_x_int),                    &
                 X_plus_Y(flux_y, flux_y_high, flux_y_int) )

    ! fluxes may need unifying to guarantee a unique flux for each face --------
    if ( extended_mesh ) then
      w2b_fs => function_space_collection%get_fs(mesh, element_order, W2Hbroken)
      call flux_broken%initialise( w2b_fs )
      call invoke( break_flux_kernel_type(flux_broken, flux_x, flux_y),        &
                   ffsl_unify_flux_kernel_type(flux_x, flux_y, flux_broken,    &
                                               1, panel_id, 1) )
    end if

    ! Compute advective increments, if required --------------------------------
    if (to_compute_adv_inc) then
      call increment_x%initialise( vector_space = field_fs )
      call increment_y%initialise( vector_space = field_fs )
      call conservative_field_x%initialise( vector_space = field_fs )
      call conservative_field_y%initialise( vector_space = field_fs )
      call inc_part%initialise( vector_space = field_fs )
      call divide_part%initialise( vector_space = field_fs )

      if ( strang ) then
        adv_one_x => transport_runtime%get_adv_unity_half_x(mesh_id)
        adv_one_y => transport_runtime%get_adv_unity_half_y(mesh_id)
      else
        adv_one_x => transport_runtime%get_adv_unity_x(mesh_id)
        adv_one_y => transport_runtime%get_adv_unity_y(mesh_id)
      end if

      ! Compute updated conservative fields
      call invoke( fv_divergence_x_kernel_type(increment_x, flux_x, m3_inv),   &
                   fv_divergence_y_kernel_type(increment_y, flux_y, m3_inv),   &
                   X_minus_bY(conservative_field_x, field_y, dt, increment_x), &
                   X_minus_bY(conservative_field_y, field_x, dt, increment_y), &

      ! Following Putman and Lin, JCP, 2007:
      ! conservative_field = q - dt * F(q)
      ! adv_one   = 1 - dt * F(1)
      ! inc_part  = q - conservative_field / adv_one
      ! increment = inc_part / dt
                   X_divideby_Y(divide_part, conservative_field_x, adv_one_x), &
                   X_minus_Y(inc_part, field_y, divide_part),                  &
                   a_times_X(increment_x, one_over_dt, inc_part),              &
                   X_divideby_Y(divide_part, conservative_field_y, adv_one_y), &
                   X_minus_Y(inc_part, field_x, divide_part),                  &
                   a_times_X(increment_y, one_over_dt, inc_part) )
    end if

    nullify(transport_runtime, mesh, dep_pts_x, dep_pts_y, detj_at_w2h,        &
            panel_id, adv_one_x, adv_one_y, field_x_ptr, field_y_ptr, m3_inv,  &
            cosmic_istart_x, cosmic_istart_y, cosmic_iend_x, cosmic_iend_y,    &
            dep_stencil_extent_x, dep_stencil_extent_y, field_fs, w2h_fs, w2b_fs)

  end subroutine ffsl_hori_final_alg

end module ffsl_hori_alg_mod
