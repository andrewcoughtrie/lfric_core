!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Apply specific humidity increments to update the moisture fields.
!> @details Inputs are specific humidity increments and the full prognostic
!>          mixing ratio fields.
!>
module iau_humidity_inc_alg_mod

  use constants_mod,                  only : r_def, i_def
  use field_collection_mod,           only : field_collection_type
  use field_mod,                      only : field_type
  use integer_field_mod,              only : integer_field_type
  use q_limit_test_kernel_mod,        only : q_limit_test_kernel_type
  use saturation_limit_kernel_mod,    only : saturation_limit_kernel_type
  use tropopause_limits_kernel_mod,   only : tropopause_limits_kernel_type

  implicit none

  public  :: iau_humidity_inc,    &
             iau_humidity_checks

contains

  !> @brief   Apply specific humidity increments to update the moisture fields.
  !> @details Inputs are specific humidity increments and the full prognostic
  !>          mixing ratio fields. The following steps are used to increment
  !>          Step 1: Calculate time level n specific quantities
  !>          Step 2: Increment to get the time level n+1 quantities
  !>          Step 3: Convert back to time level n+1 mixing ratios
  !> @param[in]     q_inc         Vapour specific humidity increment
  !> @param[in]     qcl_inc       Liquid specific humidity increment
  !> @param[in]     qcf_inc       Frozen specific humidity increment
  !> @param[in]     iau_weight    Weighting to apply to iau increment
  !> @param[in,out] m_v           Vapour mixing ratio
  !> @param[in,out] m_cl          Liquid mixing ratio
  !> @param[in,out] m_ci          Frozen mixing ratio
  !> @param[in,out] m_r           Rain mixing ratio
  !> @param[in,out] m_s           Snow mixing ratio
  !> @param[in,out] m_g           Graupel mixing ratio
  !> @param[in,out] cloud_fields  The cloud scheme
  !> @param[out]    one_minus_qs  One minus total water content
  subroutine iau_humidity_inc( q_inc, qcl_inc, qcf_inc, iau_weight, &
                               m_v, m_cl, m_ci, m_r, m_s, m_g, one_minus_qs, cloud_fields )

    implicit none

    ! Arguments
    type( field_collection_type ), intent(inout)   :: cloud_fields
    type( field_type ), intent(in)    :: q_inc, qcl_inc, qcf_inc
    type( field_type ), intent(inout) :: m_v, m_cl, m_ci, m_r, m_s, m_g
    type( field_type ), intent(out)   :: one_minus_qs
    real( kind=r_def ), intent(in)    :: iau_weight

    ! Internal fields
    type( field_type )                :: q_v
    type( field_type )                :: q_cl
    type( field_type )                :: q_ci
    type( field_type )                :: q_r
    type( field_type )                :: q_s
    type( field_type )                :: q_g
    type( field_type )                :: sum

    ! Pointers to the cloud fields
    type( field_type ), pointer :: area_fraction   => null()
    type( field_type ), pointer :: bcf => null()
    type( field_type ), pointer :: cff => null()
    type( field_type ), pointer :: cfl => null()

    ! Create local fields
    call m_v % copy_field_properties( sum )
    call m_v % copy_field_properties( q_v )
    call m_v % copy_field_properties( q_cl )
    call m_v % copy_field_properties( q_ci )
    call m_v % copy_field_properties( q_r )
    call m_v % copy_field_properties( q_s )
    call m_v % copy_field_properties( q_g )
    call m_v % copy_field_properties( one_minus_qs )

    ! Cloud_fields
    call cloud_fields % get_field( 'area_fraction', area_fraction )
    call cloud_fields % get_field( 'bulk_fraction', bcf )
    call cloud_fields % get_field( 'frozen_fraction', cff )
    call cloud_fields % get_field( 'liquid_fraction', cfl )

    ! Step 0: Calculate sum of mixing ratios (1+Sum m_x)
    call invoke( setval_c( sum, 1.0_r_def ),       &
                 inc_X_plus_Y( sum, m_v ),         &
                 inc_X_plus_Y( sum, m_cl ),        &
                 inc_X_plus_Y( sum, m_ci ),        &
                 inc_X_plus_Y( sum, m_r ),         &
                 inc_X_plus_Y( sum, m_s ),         &
                 inc_X_plus_Y( sum, m_g ),         &
    ! Step 1: Calculate time level n specific quantities and save q_v for
    !         later use
    ! q_x^n = m_x^n/(1 + sum)
                 X_divideby_Y( q_v, m_v, sum ),    &
                 X_divideby_Y( q_cl, m_cl, sum ),  &
                 X_divideby_Y( q_ci, m_ci, sum ),  &
                 X_divideby_Y( q_r, m_r, sum ),    &
                 X_divideby_Y( q_s, m_s, sum ),    &
                 X_divideby_Y( q_g, m_g, sum )     &
               )
    ! Step 2: Increment to get the time level n+1 quantities
    ! q_x^n+1 = q_x^n + q_x_inc
    call invoke( inc_X_plus_bY( q_v, iau_weight, q_inc ),       &
                 inc_X_plus_bY( q_cl, iau_weight, qcl_inc ),    &
                 inc_X_plus_bY( q_ci, iau_weight, qcf_inc ),    &
    ! Step 3: Apply the lower limits to the updated qv, qcl and qci
                 q_limit_test_kernel_type( q_v, q_cl, q_ci,        &
                                           area_fraction,          &
                                           bcf,                    &
                                           cff,                    &
                                           cfl )                   &
                )
    ! Step 4a: Calculate sum of updated specfic quantities (1-Sum q_x)
    ! Note that we re-use the 'sum' field here.
    call invoke( setval_c( sum, 1.0_r_def ),       &
                 inc_X_minus_Y( sum, q_v ),        &
                 inc_X_minus_Y( sum, q_cl ),       &
                 inc_X_minus_Y( sum, q_ci ),       &
                 inc_X_minus_Y( sum, q_r ),        &
                 inc_X_minus_Y( sum, q_s ),        &
                 inc_X_minus_Y( sum, q_g ),        &
                 setval_X(one_minus_qs, sum),      &
    ! Step 4b: Convert back to time level n+1 mixing ratios
                 X_divideby_Y( m_v, q_v, sum ),    &
                 X_divideby_Y( m_cl, q_cl, sum ),  &
                 X_divideby_Y( m_ci, q_ci, sum ),  &
                 X_divideby_Y( m_r, q_r, sum ),    &
                 X_divideby_Y( m_s, q_s, sum ),    &
                 X_divideby_Y( m_g, q_g, sum )     &
                 )
    nullify( area_fraction, bcf, cff, cfl )

  end subroutine iau_humidity_inc

  !> @brief   Apply specific humidity increments to update the moisture fields.
  !> @details Inputs are specific humidity increments and the full prognostic
  !>          mixing ratio fields. The following steps are used to increment
  !>          Step 0: Calculate sum of mixing ratios (1+Sum m_x)
  !>          Step 1: Calculate time level n specific quantities and save q_v
  !>                  for later use
  !>          Step 2: Remove supersturation wrt water
  !>          Step 3: Apply limits depending on whether in or above troposphere
  !>          Step 4a: Calculate sum of updated specfic quantities (1-Sum q_x)
  !>          Step 4b: Convert back to time level n+1 mixing ratios
  !> @param[in]     iau_weight    Weighting to apply to iau increment
  !> @param[in,out] m_v           Vapour mixing ratio
  !> @param[in,out] m_cl          Liquid mixing ratio
  !> @param[in,out] m_ci          Frozen mixing ratio
  !> @param[in,out] m_r           Rain mixing ratio
  !> @param[in,out] m_s           Snow mixing ratio
  !> @param[in,out] m_g           Graupel mixing ratio
  !> @param[in]     mv_earlier    Saved vapour mixing ratio
  !> @param[in,out] cloud_fields  The cloud scheme
  !> @param[in]     temperature   Temperature on theta levels
  !> @param[in]     pressure      Pressure on theta levels
  !> @param[in]     trop_level    Tropopause level
  subroutine iau_humidity_checks( m_v, m_cl, m_ci, m_r, m_s, m_g , cloud_fields, &
                                  mv_earlier, temperature, pressure, trop_level )

    implicit none

    ! Arguments
    type(field_collection_type), intent(inout)   :: cloud_fields
    type(integer_field_type),    intent(in)      :: trop_level
    type(field_type),            intent(in)      :: temperature, pressure
    type(field_type),            intent(inout)   :: m_v, m_cl, m_ci, m_r, m_s, m_g
    type(field_type),            intent(in)      :: mv_earlier

    ! Pointers to the cloud fields
    type( field_type ), pointer :: area_fraction   => null()
    type( field_type ), pointer :: bcf   => null()
    type( field_type ), pointer :: cff => null()
    type( field_type ), pointer :: cfl => null()

    ! Cloud_fields
    call cloud_fields % get_field( 'area_fraction', area_fraction )
    call cloud_fields % get_field( 'bulk_fraction', bcf )
    call cloud_fields % get_field( 'frozen_fraction', cff )
    call cloud_fields % get_field( 'liquid_fraction', cfl )

    ! Step 1: Remove supersaturation wrt water
    call invoke( saturation_limit_kernel_type( m_v, temperature, pressure ) )

    ! Step 2: Apply limits depending on whether in or above troposphere
    call invoke( tropopause_limits_kernel_type( m_v, m_cl, m_ci, m_r, m_s, m_g,   &
                                                cfl,                              &
                                                cff,                              &
                                                area_fraction,                    &
                                                bcf,                              &
                                                mv_earlier,                       &
                                                temperature, pressure,            &
                                                trop_level )                      &
               )

    nullify( area_fraction, bcf, cff, cfl )

  end subroutine iau_humidity_checks

end module iau_humidity_inc_alg_mod
