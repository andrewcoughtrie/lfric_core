!-------------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------

!> @brief Interface to the UM diagnostic and prognostic cloud schemes

module cld_alg_mod

  use constants_mod, only: i_def
  use field_mod, only: field_type
  use field_collection_mod,         only: field_collection_type
  use mr_indices_mod,               only: nummr, imr_v, imr_cl, imr_ci
  use io_config_mod,                only: subroutine_timers
  use timer_mod,                    only: timer
  use cloud_config_mod,             only: scheme,                        &
                                          scheme_smith,                  &
                                          scheme_pc2
  use pc2_initiation_alg_mod,       only: pc2_initiation_alg_step
  use pc2_pressure_forcing_alg_mod, only: pc2_pressure_forcing_alg_step
  use physics_mappings_alg_mod,     only: map_physics_scalars

  implicit none

  public cld_alg_step

contains

  !>@brief Run the UM Large-scale diagnostic or (parts of) prognostic cloud scheme
  !>@details The UM Diagnostic cloud scheme:
  !>         generates liquid and ice cloud fraction and water content,
  !>         and adjust vapour and temperature, as described in UMDP29
  !>         (for liquid only for now).
  !>         Parts of PC2 scheme are also done here.
  !>@param[in]     theta theta in its native space
  !>@param[in]     exner  Exner Pressure in w3 space
  !>@param[in,out] mr        Mixing ratios, in theta space
  !>@param[in,out] cloud_fields    Group of cloud fields
  !>@param[in,out] twod_fields     Group of 2D fields
  !>@param[in,out] theta_inc       Potential temperature increment in native space
  !>@param[in,out] derived_fields
  !>@param[in]     theta_n theta at start of timestep in its native space
  !>@param[in]     exner_n exner at start of timestep in its native space
  !>@param[in]     mr_n micing ratios at start of timestep
  !>@param[in]     theta_after_slow theta after slow physics in theta space
  !>@param[in]     exner_after_slow exner after slow physics in w3 space

  subroutine cld_alg_step(theta,                                    &
                          exner,                                    &
                          mr, cloud_fields, twod_fields, theta_inc, &
                          derived_fields,                           &
                          theta_n,          exner_n, mr_n,          &
                          theta_after_slow, exner_after_slow        )

    use cld_kernel_mod, only: cld_kernel_type

    implicit none

    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: twod_fields
    type( field_collection_type ), intent(inout) :: derived_fields

    ! Convention for 6 variables below is to omit their function space
    ! in their name if they are in native space. However, variable name
    ! states when in timestep variable is valid.
    type( field_type ), intent( in )    :: theta            ! Current value wth
    type( field_type ), intent( in )    :: exner            ! Current value w3
    type( field_type ), intent( in )    :: theta_n          ! Start of TS wth
    type( field_type ), intent( in )    :: exner_n          ! Start of TS w3
    type( field_type ), intent( in )    :: theta_after_slow ! After slowphys wth
    type( field_type ), intent( in )    :: exner_after_slow ! After slowphys w3
    ! 2 variables below are for remapping from w3 to wth.
    type( field_type ) :: exner_wth                         ! Current
    type( field_type ) :: exner_after_slow_wth              ! After slowphys

    type( field_type ), intent( inout ) :: theta_inc, mr(nummr), mr_n(nummr)

    type( field_type ), pointer :: cf_area  => null()
    type( field_type ), pointer :: cf_ice  => null()
    type( field_type ), pointer :: cf_liq  => null()
    type( field_type ), pointer :: cf_bulk  => null()
    type( field_type ), pointer :: ntml_2d => null()
    type( field_type ), pointer :: cumulus_2d => null()
    type( field_type ), pointer :: rh_crit_wth => null()

    type( field_type ) :: dtheta_pc2_inc
    type( field_type ) :: dtheta_pc2_inc_pres
    type( field_type ) :: theta_updated

    if ( subroutine_timers ) call timer('cld_alg_step')

    call theta%copy_field_properties(exner_wth)
    call map_physics_scalars(exner_wth, exner)

    if (scheme == scheme_smith) then

      cf_area => cloud_fields%get_field('area_fraction')
      cf_ice => cloud_fields%get_field('ice_fraction')
      cf_liq => cloud_fields%get_field('liquid_fraction')
      cf_bulk => cloud_fields%get_field('bulk_fraction')

      rh_crit_wth => cloud_fields%get_field('rh_crit_wth')

      ntml_2d => twod_fields%get_field('ntml')
      cumulus_2d => twod_fields%get_field('cumulus')

      call invoke( cld_kernel_type( theta, exner , exner_wth,      &
                                    rh_crit_wth, ntml_2d, cumulus_2d,              &
                                    mr(imr_v), mr(imr_cl), mr(imr_ci),             &
                                    cf_area, cf_ice, cf_liq, cf_bulk, theta_inc)   )

    else if (scheme == scheme_pc2) then

      call theta%copy_field_properties(exner_after_slow_wth)
      call map_physics_scalars(exner_after_slow_wth, exner_after_slow)

      call theta%copy_field_properties(dtheta_pc2_inc_pres)
      call invoke( setval_c(dtheta_pc2_inc_pres,   0.0_r_def) )

      ! Do PC2 Pressure forcing
      call pc2_pressure_forcing_alg_step( mr,                      & ! IN
                                          theta,                   & ! IN
                                          theta_after_slow,        & ! IN
                                          exner_wth,               & ! IN wth
                                          exner_after_slow_wth,    & ! IN
                                          cloud_fields,            & ! INOUT
                                          dtheta_pc2_inc_pres )      ! OUT

      ! Temporary value of theta to be updated with increment from
      ! pressure forcing for use as input for initiation.
      call theta%copy_field(theta_updated)
      call invoke( inc_X_plus_Y(theta_updated, dtheta_pc2_inc_pres) )

      ! Now do PC2 initiation (and checks)
      call pc2_initiation_alg_step( mr,                  & ! INOUT Current
                                    theta_updated,       & ! IN    Updated
                                    exner,               & ! IN    Current exner w3
                                    exner_wth,           & ! IN    Current exner wth
                                    mr_n,                & ! IN    Start of timestep
                                    theta_n,             & ! IN    Start of timestep
                                    derived_fields,      & ! IN
                                    twod_fields,         &
                                    cloud_fields,        & ! INOUT
                                    theta_inc )            ! OUT

      call invoke( inc_X_plus_Y(theta_inc,    dtheta_pc2_inc_pres) )

    end if

    if ( subroutine_timers ) call timer('cld_alg_step')

  end subroutine cld_alg_step

end module cld_alg_mod
